// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: ticket_messages.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countTicketMessagesByTicketIDAndPageInfo = `-- name: CountTicketMessagesByTicketIDAndPageInfo :one
WITH _count_wrapper AS (
	SELECT
		id, ticket_id, sender_id, message, read, created_at, updated_at, deleted_at
	FROM
		ticket_messages
	WHERE
		ticket_id = $1
		AND created_at < $2
		AND deleted_at IS NULL
	ORDER BY
		created_at DESC
	LIMIT
		$3
)
SELECT
	count(*)
FROM
	_count_wrapper
`

type CountTicketMessagesByTicketIDAndPageInfoParams struct {
	TicketID  uuid.UUID
	CreatedAt time.Time
	Limit     int32
}

func (q *Queries) CountTicketMessagesByTicketIDAndPageInfo(ctx context.Context, arg CountTicketMessagesByTicketIDAndPageInfoParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTicketMessagesByTicketIDAndPageInfo, arg.TicketID, arg.CreatedAt, arg.Limit)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTicketMessage = `-- name: CreateTicketMessage :one
INSERT INTO
	ticket_messages (sender_id, ticket_id, message)
VALUES
	($1, $2, $3) RETURNING id, ticket_id, sender_id, message, read, created_at, updated_at, deleted_at
`

type CreateTicketMessageParams struct {
	SenderID uuid.UUID
	TicketID uuid.UUID
	Message  string
}

func (q *Queries) CreateTicketMessage(ctx context.Context, arg CreateTicketMessageParams) (*TicketMessage, error) {
	row := q.db.QueryRowContext(ctx, createTicketMessage, arg.SenderID, arg.TicketID, arg.Message)
	var i TicketMessage
	err := row.Scan(
		&i.ID,
		&i.TicketID,
		&i.SenderID,
		&i.Message,
		&i.Read,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getLastTicketMessageByTicketID = `-- name: GetLastTicketMessageByTicketID :one
SELECT
	id, ticket_id, sender_id, message, read, created_at, updated_at, deleted_at
FROM
	ticket_messages
WHERE
	ticket_id = $1
	AND deleted_at IS NULL
ORDER BY
	created_at DESC
LIMIT
	1
`

func (q *Queries) GetLastTicketMessageByTicketID(ctx context.Context, ticketID uuid.UUID) (*TicketMessage, error) {
	row := q.db.QueryRowContext(ctx, getLastTicketMessageByTicketID, ticketID)
	var i TicketMessage
	err := row.Scan(
		&i.ID,
		&i.TicketID,
		&i.SenderID,
		&i.Message,
		&i.Read,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTicketMessageByID = `-- name: GetTicketMessageByID :one
SELECT
	id, ticket_id, sender_id, message, read, created_at, updated_at, deleted_at
FROM
	ticket_messages
WHERE
	id = $1
	AND deleted_at IS NULL
`

func (q *Queries) GetTicketMessageByID(ctx context.Context, id uuid.UUID) (*TicketMessage, error) {
	row := q.db.QueryRowContext(ctx, getTicketMessageByID, id)
	var i TicketMessage
	err := row.Scan(
		&i.ID,
		&i.TicketID,
		&i.SenderID,
		&i.Message,
		&i.Read,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTicketMessagesByTicketIDAndPageInfo = `-- name: GetTicketMessagesByTicketIDAndPageInfo :many
SELECT
	id, ticket_id, sender_id, message, read, created_at, updated_at, deleted_at
FROM
	ticket_messages
WHERE
	ticket_id = $1
	AND created_at < $2
	AND deleted_at IS NULL
ORDER BY
	created_at DESC
LIMIT
	$3
`

type GetTicketMessagesByTicketIDAndPageInfoParams struct {
	TicketID  uuid.UUID
	CreatedAt time.Time
	Limit     int32
}

func (q *Queries) GetTicketMessagesByTicketIDAndPageInfo(ctx context.Context, arg GetTicketMessagesByTicketIDAndPageInfoParams) ([]*TicketMessage, error) {
	rows, err := q.db.QueryContext(ctx, getTicketMessagesByTicketIDAndPageInfo, arg.TicketID, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*TicketMessage{}
	for rows.Next() {
		var i TicketMessage
		if err := rows.Scan(
			&i.ID,
			&i.TicketID,
			&i.SenderID,
			&i.Message,
			&i.Read,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReadTicketMessagesByUserIDAndTicketID = `-- name: UpdateReadTicketMessagesByUserIDAndTicketID :many
UPDATE
	ticket_messages
SET
	READ = TRUE
WHERE
	sender_id = $1
	AND ticket_id = $2
	AND deleted_at IS NULL RETURNING id
`

type UpdateReadTicketMessagesByUserIDAndTicketIDParams struct {
	SenderID uuid.UUID
	TicketID uuid.UUID
}

func (q *Queries) UpdateReadTicketMessagesByUserIDAndTicketID(ctx context.Context, arg UpdateReadTicketMessagesByUserIDAndTicketIDParams) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, updateReadTicketMessagesByUserIDAndTicketID, arg.SenderID, arg.TicketID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
