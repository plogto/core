// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: tags.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createTag = `-- name: CreateTag :one
INSERT INTO
	tags (NAME)
VALUES
	($1) RETURNING id, name, created_at, updated_at, deleted_at
`

func (q *Queries) CreateTag(ctx context.Context, name string) (*Tag, error) {
	row := q.db.QueryRowContext(ctx, createTag, name)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTagByIDs = `-- name: GetTagByIDs :many
SELECT
	id, name, created_at, updated_at, deleted_at
FROM
	tags
WHERE
	id = ANY($1 :: uuid [ ])
	AND deleted_at IS NULL
`

func (q *Queries) GetTagByIDs(ctx context.Context, ids []uuid.UUID) ([]*Tag, error) {
	rows, err := q.db.QueryContext(ctx, getTagByIDs, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagByName = `-- name: GetTagByName :one
SELECT
	id, name, created_at, updated_at, deleted_at
FROM
	tags
WHERE
	lower(tag.name) = lower($1)
	AND deleted_at IS NULL
`

func (q *Queries) GetTagByName(ctx context.Context, name string) (*Tag, error) {
	row := q.db.QueryRowContext(ctx, getTagByName, name)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTagsByTagNameAndPageInfo = `-- name: GetTagsByTagNameAndPageInfo :many
SELECT
	tag.id, tag.name, tag.created_at, tag.updated_at, tag.deleted_at,
	count(tag.id),
	post_tags.tag_id
FROM
	tags AS tag
	INNER JOIN post_tags ON post_tags.tag_id = tag.id
	INNER JOIN posts ON post_tags.post_id = posts.id
	INNER JOIN users ON users.id = posts.user_id
WHERE
	lower(tag.name) LIKE lower($2)
	AND posts.deleted_at IS NULL
	AND users.is_private IS FALSE
GROUP BY
	tag.id,
	post_tags.tag_id
ORDER BY
	count DESC,
	tag.created_at DESC
LIMIT
	$1
`

type GetTagsByTagNameAndPageInfoParams struct {
	Limit int32
	Name  string
}

type GetTagsByTagNameAndPageInfoRow struct {
	ID        uuid.UUID
	Name      string
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt sql.NullTime
	Count     int64
	TagID     uuid.UUID
}

func (q *Queries) GetTagsByTagNameAndPageInfo(ctx context.Context, arg GetTagsByTagNameAndPageInfoParams) ([]*GetTagsByTagNameAndPageInfoRow, error) {
	rows, err := q.db.QueryContext(ctx, getTagsByTagNameAndPageInfo, arg.Limit, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetTagsByTagNameAndPageInfoRow{}
	for rows.Next() {
		var i GetTagsByTagNameAndPageInfoRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Count,
			&i.TagID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
