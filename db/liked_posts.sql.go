// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: liked_posts.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countLikedPostsByPostIDAndPageInfo = `-- name: CountLikedPostsByPostIDAndPageInfo :one
WITH _count_wrapper AS (
	SELECT
		count(*)
	FROM
		liked_posts
	WHERE
		post_id = $1
		AND created_at < $2
		AND deleted_at IS NULL
	GROUP BY
		created_at
	ORDER BY
		created_at DESC
)
SELECT
	count(*)
FROM
	_count_wrapper
`

type CountLikedPostsByPostIDAndPageInfoParams struct {
	PostID    pgtype.UUID
	CreatedAt time.Time
}

func (q *Queries) CountLikedPostsByPostIDAndPageInfo(ctx context.Context, arg CountLikedPostsByPostIDAndPageInfoParams) (int64, error) {
	row := q.db.QueryRow(ctx, countLikedPostsByPostIDAndPageInfo, arg.PostID, arg.CreatedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLikedPostsByUserIDAndPageInfo = `-- name: CountLikedPostsByUserIDAndPageInfo :one
WITH _count_wrapper AS (
	SELECT
		count(*)
	FROM
		liked_posts AS liked_post
		INNER JOIN posts ON posts.id = liked_post.post_id
		INNER JOIN users ON users.id = posts.user_id
		FULL OUTER JOIN connections ON connections.following_id = posts.user_id
	WHERE
		liked_post.user_id = $1
		AND liked_post.deleted_at IS NULL
		AND posts.deleted_at IS NULL
		AND (
			connections.status = 2
			OR users.is_private = FALSE
		)
		AND (
			users.id = $1
			OR connections.deleted_at IS NULL
		)
		AND liked_post.created_at < $2
	GROUP BY
		liked_post.id,
		posts.id,
		users.id
)
SELECT
	count(*)
FROM
	_count_wrapper
`

type CountLikedPostsByUserIDAndPageInfoParams struct {
	UserID    pgtype.UUID
	CreatedAt time.Time
}

func (q *Queries) CountLikedPostsByUserIDAndPageInfo(ctx context.Context, arg CountLikedPostsByUserIDAndPageInfoParams) (int64, error) {
	row := q.db.QueryRow(ctx, countLikedPostsByUserIDAndPageInfo, arg.UserID, arg.CreatedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLikedPost = `-- name: CreateLikedPost :one
INSERT INTO
	liked_posts (user_id, post_id)
VALUES
	($1, $2) RETURNING id, user_id, post_id, created_at, updated_at, deleted_at
`

type CreateLikedPostParams struct {
	UserID pgtype.UUID
	PostID pgtype.UUID
}

func (q *Queries) CreateLikedPost(ctx context.Context, arg CreateLikedPostParams) (*LikedPost, error) {
	row := q.db.QueryRow(ctx, createLikedPost, arg.UserID, arg.PostID)
	var i LikedPost
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PostID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteLikedPostByID = `-- name: DeleteLikedPostByID :one
UPDATE
	liked_posts
SET
	deleted_at = $1
WHERE
	id = $2
	AND deleted_at IS NULL RETURNING id, user_id, post_id, created_at, updated_at, deleted_at
`

type DeleteLikedPostByIDParams struct {
	DeletedAt *time.Time
	ID        pgtype.UUID
}

func (q *Queries) DeleteLikedPostByID(ctx context.Context, arg DeleteLikedPostByIDParams) (*LikedPost, error) {
	row := q.db.QueryRow(ctx, deleteLikedPostByID, arg.DeletedAt, arg.ID)
	var i LikedPost
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PostID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getLikedPostByID = `-- name: GetLikedPostByID :one
SELECT
	id, user_id, post_id, created_at, updated_at, deleted_at
FROM
	liked_posts
WHERE
	id = $1
	AND deleted_at IS NULL
`

func (q *Queries) GetLikedPostByID(ctx context.Context, id pgtype.UUID) (*LikedPost, error) {
	row := q.db.QueryRow(ctx, getLikedPostByID, id)
	var i LikedPost
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PostID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getLikedPostByUserIDAndPostID = `-- name: GetLikedPostByUserIDAndPostID :one
SELECT
	id, user_id, post_id, created_at, updated_at, deleted_at
FROM
	liked_posts
WHERE
	user_id = $1
	AND post_id = $2
	AND deleted_at IS NULL
`

type GetLikedPostByUserIDAndPostIDParams struct {
	UserID pgtype.UUID
	PostID pgtype.UUID
}

func (q *Queries) GetLikedPostByUserIDAndPostID(ctx context.Context, arg GetLikedPostByUserIDAndPostIDParams) (*LikedPost, error) {
	row := q.db.QueryRow(ctx, getLikedPostByUserIDAndPostID, arg.UserID, arg.PostID)
	var i LikedPost
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PostID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getLikedPostsByPostIDAndPageInfo = `-- name: GetLikedPostsByPostIDAndPageInfo :many
SELECT
	id, user_id, post_id, created_at, updated_at, deleted_at
FROM
	liked_posts
WHERE
	post_id = $1
	AND created_at < $2
	AND deleted_at IS NULL
GROUP BY
	id,
	created_at
ORDER BY
	created_at DESC
LIMIT
	$3
`

type GetLikedPostsByPostIDAndPageInfoParams struct {
	PostID    pgtype.UUID
	CreatedAt time.Time
	Limit     int32
}

func (q *Queries) GetLikedPostsByPostIDAndPageInfo(ctx context.Context, arg GetLikedPostsByPostIDAndPageInfoParams) ([]*LikedPost, error) {
	rows, err := q.db.Query(ctx, getLikedPostsByPostIDAndPageInfo, arg.PostID, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*LikedPost{}
	for rows.Next() {
		var i LikedPost
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PostID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLikedPostsByUserIDAndPageInfo = `-- name: GetLikedPostsByUserIDAndPageInfo :many
WITH _count_wrapper AS (
	SELECT
		liked_post.id AS liked_post_id,
		liked_post.post_id AS liked_post_post_id,
		liked_post.user_id AS liked_post_user_id,
		liked_post.created_at,
		liked_post.deleted_at AS liked_post_deleted_at,
		connections.id AS connection_id,
		connections.status,
		connections.deleted_at AS connection_deleted_at,
		posts.id AS post_id,
		posts.user_id AS post_user_id,
		posts.deleted_at AS post_deleted_at,
		users.id AS user_id,
		users.is_private
	FROM
		liked_posts AS liked_post
		INNER JOIN posts ON posts.id = liked_post.post_id
		INNER JOIN users ON users.id = posts.user_id
		FULL OUTER JOIN connections ON connections.following_id = posts.user_id
	WHERE
		liked_post.user_id = $2
		AND liked_post.deleted_at IS NULL
		AND posts.deleted_at IS NULL
		AND (
			connections.status = 2
			OR users.is_private = FALSE
		)
		AND (
			users.id = $2
			OR connections.deleted_at IS NULL
		)
		AND liked_post.created_at < $3
	GROUP BY
		connections.id,
		liked_post.id,
		posts.id,
		users.id
)
SELECT
	liked_post_id AS id,
	user_id,
	post_id,
	created_at
FROM
	_count_wrapper
GROUP BY
	id,
	user_id,
	post_id,
	created_at
ORDER BY
	created_at DESC
LIMIT
	$1
`

type GetLikedPostsByUserIDAndPageInfoParams struct {
	Limit     int32
	UserID    pgtype.UUID
	CreatedAt time.Time
}

type GetLikedPostsByUserIDAndPageInfoRow struct {
	ID        pgtype.UUID
	UserID    pgtype.UUID
	PostID    pgtype.UUID
	CreatedAt time.Time
}

func (q *Queries) GetLikedPostsByUserIDAndPageInfo(ctx context.Context, arg GetLikedPostsByUserIDAndPageInfoParams) ([]*GetLikedPostsByUserIDAndPageInfoRow, error) {
	rows, err := q.db.Query(ctx, getLikedPostsByUserIDAndPageInfo, arg.Limit, arg.UserID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetLikedPostsByUserIDAndPageInfoRow{}
	for rows.Next() {
		var i GetLikedPostsByUserIDAndPageInfoRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PostID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
