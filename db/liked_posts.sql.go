// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: liked_posts.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const countLikedPostsByPageInfo = `-- name: CountLikedPostsByPageInfo :one
WITH _count_wrapper AS (
	SELECT
		count(*)
	FROM
		liked_posts AS liked_post
		INNER JOIN posts ON posts.id = liked_post.post_id
		INNER JOIN users ON users.id = posts.user_id
	WHERE
		liked_post.user_id = $1
		AND liked_post.deleted_at IS NULL
		AND posts.deleted_at IS NULL
		AND (
			users.id = $1
			OR users.is_private = FALSE
		)
		AND liked_post.created_at < $2
	GROUP BY
		liked_post.id,
		posts.id,
		users.id
)
SELECT
	count(*)
FROM
	_count_wrapper
`

type CountLikedPostsByPageInfoParams struct {
	UserID    uuid.UUID
	CreatedAt time.Time
}

func (q *Queries) CountLikedPostsByPageInfo(ctx context.Context, arg CountLikedPostsByPageInfoParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLikedPostsByPageInfo, arg.UserID, arg.CreatedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLikedPostsByPostIDAndPageInfo = `-- name: CountLikedPostsByPostIDAndPageInfo :one
WITH _count_wrapper AS (
	SELECT
		count(*)
	FROM
		liked_posts
	WHERE
		post_id = $1
		AND created_at < $2
		AND deleted_at IS NULL
	GROUP BY
		created_at
	ORDER BY
		created_at DESC
)
SELECT
	count(*)
FROM
	_count_wrapper
`

type CountLikedPostsByPostIDAndPageInfoParams struct {
	PostID    uuid.UUID
	CreatedAt time.Time
}

func (q *Queries) CountLikedPostsByPostIDAndPageInfo(ctx context.Context, arg CountLikedPostsByPostIDAndPageInfoParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLikedPostsByPostIDAndPageInfo, arg.PostID, arg.CreatedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLikedPostsByUserIDAndPageInfo = `-- name: CountLikedPostsByUserIDAndPageInfo :one
WITH _count_wrapper AS (
	SELECT
		count(*)
	FROM
		liked_posts AS liked_post
		INNER JOIN posts ON posts.id = liked_post.post_id
		INNER JOIN users ON users.id = posts.user_id
		FULL OUTER JOIN connections ON connections.following_id = posts.user_id
	WHERE
		liked_post.user_id = $1
		AND liked_post.deleted_at IS NULL
		AND posts.deleted_at IS NULL
		AND (
			users.id = $1
			OR connections.status = 2
			OR users.is_private = FALSE
		)
		AND connections.deleted_at IS NULL
		AND liked_post.created_at < $2
	GROUP BY
		connections.id,
		liked_post.id,
		posts.id,
		users.id
)
SELECT
	count(*)
FROM
	_count_wrapper
`

type CountLikedPostsByUserIDAndPageInfoParams struct {
	UserID    uuid.UUID
	CreatedAt time.Time
}

func (q *Queries) CountLikedPostsByUserIDAndPageInfo(ctx context.Context, arg CountLikedPostsByUserIDAndPageInfoParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLikedPostsByUserIDAndPageInfo, arg.UserID, arg.CreatedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLikedPost = `-- name: CreateLikedPost :one
INSERT INTO
	liked_posts (user_id, post_id)
VALUES
	($1, $2) RETURNING id, user_id, post_id, created_at, updated_at, deleted_at
`

type CreateLikedPostParams struct {
	UserID uuid.UUID
	PostID uuid.UUID
}

func (q *Queries) CreateLikedPost(ctx context.Context, arg CreateLikedPostParams) (*LikedPost, error) {
	row := q.db.QueryRowContext(ctx, createLikedPost, arg.UserID, arg.PostID)
	var i LikedPost
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PostID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteLikedPostByID = `-- name: DeleteLikedPostByID :one
UPDATE
	liked_posts
SET
	deleted_at = $1
WHERE
	id = $2
	AND deleted_at IS NULL RETURNING id, user_id, post_id, created_at, updated_at, deleted_at
`

type DeleteLikedPostByIDParams struct {
	DeletedAt sql.NullTime
	ID        uuid.UUID
}

func (q *Queries) DeleteLikedPostByID(ctx context.Context, arg DeleteLikedPostByIDParams) (*LikedPost, error) {
	row := q.db.QueryRowContext(ctx, deleteLikedPostByID, arg.DeletedAt, arg.ID)
	var i LikedPost
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PostID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getLikedPostByID = `-- name: GetLikedPostByID :one
SELECT
	id, user_id, post_id, created_at, updated_at, deleted_at
FROM
	liked_posts
WHERE
	id = $1
	AND deleted_at IS NULL
`

func (q *Queries) GetLikedPostByID(ctx context.Context, id uuid.UUID) (*LikedPost, error) {
	row := q.db.QueryRowContext(ctx, getLikedPostByID, id)
	var i LikedPost
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PostID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getLikedPostByUserIDAndPostID = `-- name: GetLikedPostByUserIDAndPostID :one
SELECT
	id, user_id, post_id, created_at, updated_at, deleted_at
FROM
	liked_posts
WHERE
	user_id = $1
	AND post_id = $2
	AND deleted_at IS NULL
`

type GetLikedPostByUserIDAndPostIDParams struct {
	UserID uuid.UUID
	PostID uuid.UUID
}

func (q *Queries) GetLikedPostByUserIDAndPostID(ctx context.Context, arg GetLikedPostByUserIDAndPostIDParams) (*LikedPost, error) {
	row := q.db.QueryRowContext(ctx, getLikedPostByUserIDAndPostID, arg.UserID, arg.PostID)
	var i LikedPost
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PostID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getLikedPostsByPageInfo = `-- name: GetLikedPostsByPageInfo :many
SELECT
	liked_post.id, liked_post.user_id, post_id, liked_post.created_at, liked_post.updated_at, liked_post.deleted_at, posts.id, posts.user_id, parent_id, child_id, status, content, url, posts.created_at, posts.updated_at, posts.deleted_at, users.id, username, email, full_name, bio, role, is_private, avatar, background, primary_color, background_color, is_verified, invitation_code, users.created_at, users.updated_at, users.deleted_at
FROM
	liked_posts AS liked_post
	INNER JOIN posts ON posts.id = liked_post.post_id
	INNER JOIN users ON users.id = posts.user_id
WHERE
	liked_post.user_id = $1
	AND (liked_post.deleted_at IS NULL)
	AND (posts.deleted_at IS NULL)
	AND (
		users.id = $1
		OR users.is_private = FALSE
	)
	AND liked_post.created_at < $2
GROUP BY
	liked_post.id,
	posts.id,
	users.id
LIMIT
	$3
`

type GetLikedPostsByPageInfoParams struct {
	UserID    uuid.UUID
	CreatedAt time.Time
	Limit     int32
}

type GetLikedPostsByPageInfoRow struct {
	ID              uuid.UUID
	UserID          uuid.UUID
	PostID          uuid.UUID
	CreatedAt       time.Time
	UpdatedAt       time.Time
	DeletedAt       sql.NullTime
	ID_2            uuid.UUID
	UserID_2        uuid.UUID
	ParentID        uuid.NullUUID
	ChildID         uuid.NullUUID
	Status          PostStatus
	Content         sql.NullString
	Url             string
	CreatedAt_2     time.Time
	UpdatedAt_2     time.Time
	DeletedAt_2     sql.NullTime
	ID_3            uuid.UUID
	Username        string
	Email           string
	FullName        string
	Bio             sql.NullString
	Role            UserRole
	IsPrivate       bool
	Avatar          uuid.NullUUID
	Background      uuid.NullUUID
	PrimaryColor    PrimaryColor
	BackgroundColor BackgroundColor
	IsVerified      bool
	InvitationCode  string
	CreatedAt_3     time.Time
	UpdatedAt_3     time.Time
	DeletedAt_3     sql.NullTime
}

func (q *Queries) GetLikedPostsByPageInfo(ctx context.Context, arg GetLikedPostsByPageInfoParams) ([]*GetLikedPostsByPageInfoRow, error) {
	rows, err := q.db.QueryContext(ctx, getLikedPostsByPageInfo, arg.UserID, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetLikedPostsByPageInfoRow{}
	for rows.Next() {
		var i GetLikedPostsByPageInfoRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PostID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.UserID_2,
			&i.ParentID,
			&i.ChildID,
			&i.Status,
			&i.Content,
			&i.Url,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeletedAt_2,
			&i.ID_3,
			&i.Username,
			&i.Email,
			&i.FullName,
			&i.Bio,
			&i.Role,
			&i.IsPrivate,
			&i.Avatar,
			&i.Background,
			&i.PrimaryColor,
			&i.BackgroundColor,
			&i.IsVerified,
			&i.InvitationCode,
			&i.CreatedAt_3,
			&i.UpdatedAt_3,
			&i.DeletedAt_3,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLikedPostsByPostIDAndPageInfo = `-- name: GetLikedPostsByPostIDAndPageInfo :many
SELECT
	id, user_id, post_id, created_at, updated_at, deleted_at
FROM
	liked_posts
WHERE
	post_id = $1
	AND created_at < $2
	AND deleted_at IS NULL
GROUP BY
	id,
	created_at
ORDER BY
	created_at DESC
LIMIT
	$3
`

type GetLikedPostsByPostIDAndPageInfoParams struct {
	PostID    uuid.UUID
	CreatedAt time.Time
	Limit     int32
}

func (q *Queries) GetLikedPostsByPostIDAndPageInfo(ctx context.Context, arg GetLikedPostsByPostIDAndPageInfoParams) ([]*LikedPost, error) {
	rows, err := q.db.QueryContext(ctx, getLikedPostsByPostIDAndPageInfo, arg.PostID, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*LikedPost{}
	for rows.Next() {
		var i LikedPost
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PostID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLikedPostsByUserIDAndPageInfo = `-- name: GetLikedPostsByUserIDAndPageInfo :many
SELECT
	liked_post.id, liked_post.user_id, post_id, liked_post.created_at, liked_post.updated_at, liked_post.deleted_at, posts.id, posts.user_id, parent_id, child_id, posts.status, content, url, posts.created_at, posts.updated_at, posts.deleted_at, users.id, username, email, full_name, bio, role, is_private, avatar, background, primary_color, background_color, is_verified, invitation_code, users.created_at, users.updated_at, users.deleted_at, connections.id, follower_id, following_id, connections.status, connections.created_at, connections.updated_at, connections.deleted_at
FROM
	liked_posts AS liked_post
	INNER JOIN posts ON posts.id = liked_post.post_id
	INNER JOIN users ON users.id = posts.user_id
	FULL OUTER JOIN connections ON connections.following_id = posts.user_id
WHERE
	liked_post.user_id = $2
	AND liked_post.deleted_at IS NULL
	AND posts.deleted_at IS NULL
	AND (
		users.id = $2
		OR connections.status = 2
		OR users.is_private = FALSE
	)
	AND connections.deleted_at IS NULL
	AND liked_post.created_at < $3
GROUP BY
	connections.id,
	liked_post.id,
	posts.id,
	users.id
LIMIT
	$1
`

type GetLikedPostsByUserIDAndPageInfoParams struct {
	Limit     int32
	UserID    uuid.UUID
	CreatedAt time.Time
}

type GetLikedPostsByUserIDAndPageInfoRow struct {
	ID              uuid.UUID
	UserID          uuid.UUID
	PostID          uuid.UUID
	CreatedAt       time.Time
	UpdatedAt       time.Time
	DeletedAt       sql.NullTime
	ID_2            uuid.UUID
	UserID_2        uuid.UUID
	ParentID        uuid.NullUUID
	ChildID         uuid.NullUUID
	Status          PostStatus
	Content         sql.NullString
	Url             string
	CreatedAt_2     time.Time
	UpdatedAt_2     time.Time
	DeletedAt_2     sql.NullTime
	ID_3            uuid.UUID
	Username        string
	Email           string
	FullName        string
	Bio             sql.NullString
	Role            UserRole
	IsPrivate       bool
	Avatar          uuid.NullUUID
	Background      uuid.NullUUID
	PrimaryColor    PrimaryColor
	BackgroundColor BackgroundColor
	IsVerified      bool
	InvitationCode  string
	CreatedAt_3     time.Time
	UpdatedAt_3     time.Time
	DeletedAt_3     sql.NullTime
	ID_4            uuid.NullUUID
	FollowerID      uuid.NullUUID
	FollowingID     uuid.NullUUID
	Status_2        sql.NullInt32
	CreatedAt_4     sql.NullTime
	UpdatedAt_4     sql.NullTime
	DeletedAt_4     sql.NullTime
}

func (q *Queries) GetLikedPostsByUserIDAndPageInfo(ctx context.Context, arg GetLikedPostsByUserIDAndPageInfoParams) ([]*GetLikedPostsByUserIDAndPageInfoRow, error) {
	rows, err := q.db.QueryContext(ctx, getLikedPostsByUserIDAndPageInfo, arg.Limit, arg.UserID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetLikedPostsByUserIDAndPageInfoRow{}
	for rows.Next() {
		var i GetLikedPostsByUserIDAndPageInfoRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PostID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.UserID_2,
			&i.ParentID,
			&i.ChildID,
			&i.Status,
			&i.Content,
			&i.Url,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeletedAt_2,
			&i.ID_3,
			&i.Username,
			&i.Email,
			&i.FullName,
			&i.Bio,
			&i.Role,
			&i.IsPrivate,
			&i.Avatar,
			&i.Background,
			&i.PrimaryColor,
			&i.BackgroundColor,
			&i.IsVerified,
			&i.InvitationCode,
			&i.CreatedAt_3,
			&i.UpdatedAt_3,
			&i.DeletedAt_3,
			&i.ID_4,
			&i.FollowerID,
			&i.FollowingID,
			&i.Status_2,
			&i.CreatedAt_4,
			&i.UpdatedAt_4,
			&i.DeletedAt_4,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
