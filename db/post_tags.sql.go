// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: post_tags.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPostTagsByTagID = `-- name: CountPostTagsByTagID :one
WITH _count_wrapper AS (
	SELECT
		post_tag.id, post_tag.tag_id, post_tag.post_id, post_tag.created_at, post_tag.updated_at, post_tag.deleted_at
	FROM
		post_tags AS post_tag
		INNER JOIN posts ON posts.id = post_tag.post_id
		INNER JOIN users ON users.id = posts.user_id
	WHERE
		post_tag.tag_id = $1
		AND posts.deleted_at IS NULL
		AND users.is_private IS FALSE
	GROUP BY
		post_tag.tag_id,
		post_tag.id
)
SELECT
	count(*)
FROM
	_count_wrapper
`

func (q *Queries) CountPostTagsByTagID(ctx context.Context, tagID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPostTagsByTagID, tagID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPostTag = `-- name: CreatePostTag :one
INSERT INTO
	post_tags (tag_id, post_id)
VALUES
	($1, $2) RETURNING id, tag_id, post_id, created_at, updated_at, deleted_at
`

type CreatePostTagParams struct {
	TagID  pgtype.UUID
	PostID pgtype.UUID
}

func (q *Queries) CreatePostTag(ctx context.Context, arg CreatePostTagParams) (*PostTag, error) {
	row := q.db.QueryRow(ctx, createPostTag, arg.TagID, arg.PostID)
	var i PostTag
	err := row.Scan(
		&i.ID,
		&i.TagID,
		&i.PostID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deletePostTagsByPostID = `-- name: DeletePostTagsByPostID :many
UPDATE
	post_tags
SET
	deleted_at = $1
WHERE
	post_id = $2
	AND deleted_at IS NULL RETURNING id, tag_id, post_id, created_at, updated_at, deleted_at
`

type DeletePostTagsByPostIDParams struct {
	DeletedAt *time.Time
	PostID    pgtype.UUID
}

func (q *Queries) DeletePostTagsByPostID(ctx context.Context, arg DeletePostTagsByPostIDParams) ([]*PostTag, error) {
	rows, err := q.db.Query(ctx, deletePostTagsByPostID, arg.DeletedAt, arg.PostID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PostTag{}
	for rows.Next() {
		var i PostTag
		if err := rows.Scan(
			&i.ID,
			&i.TagID,
			&i.PostID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsOrderByCountTags = `-- name: GetTagsOrderByCountTags :many
SELECT
	tag.id, tag.name, tag.created_at, tag.updated_at, tag.deleted_at,
	count(tag.id)
FROM
	tags AS tag
	INNER JOIN post_tags ON post_tags.tag_id = tag.id
	INNER JOIN posts ON post_tags.post_id = posts.id
	INNER JOIN users ON users.id = posts.user_id
WHERE
	posts.deleted_at IS NULL
	AND users.is_private IS FALSE
GROUP BY
	tag.id,
	post_tags.tag_id
ORDER BY
	count DESC,
	tag.created_at DESC
LIMIT
	$1
`

type GetTagsOrderByCountTagsRow struct {
	ID        pgtype.UUID
	Name      string
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt *time.Time
	Count     int64
}

func (q *Queries) GetTagsOrderByCountTags(ctx context.Context, limit int32) ([]*GetTagsOrderByCountTagsRow, error) {
	rows, err := q.db.Query(ctx, getTagsOrderByCountTags, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetTagsOrderByCountTagsRow{}
	for rows.Next() {
		var i GetTagsOrderByCountTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
