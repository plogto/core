// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: tickets.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countTicketsByUserIDAndPageInfo = `-- name: CountTicketsByUserIDAndPageInfo :one
WITH _count_wrapper AS (
	SELECT
		id, user_id, subject, status, url, created_at, updated_at, deleted_at
	FROM
		tickets
	WHERE
		(
			user_id = $2
			OR $2 IS NULL
		)
		AND updated_at < $1
		AND deleted_at IS NULL
	ORDER BY
		updated_at DESC
)
SELECT
	count(*)
FROM
	_count_wrapper
`

type CountTicketsByUserIDAndPageInfoParams struct {
	UpdatedAt time.Time
	UserID    uuid.NullUUID
}

func (q *Queries) CountTicketsByUserIDAndPageInfo(ctx context.Context, arg CountTicketsByUserIDAndPageInfoParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTicketsByUserIDAndPageInfo, arg.UpdatedAt, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTicket = `-- name: CreateTicket :one
INSERT INTO
	tickets (user_id, subject, url)
VALUES
	($1, $2, $3) RETURNING id, user_id, subject, status, url, created_at, updated_at, deleted_at
`

type CreateTicketParams struct {
	UserID  uuid.UUID
	Subject string
	Url     string
}

func (q *Queries) CreateTicket(ctx context.Context, arg CreateTicketParams) (*Ticket, error) {
	row := q.db.QueryRowContext(ctx, createTicket, arg.UserID, arg.Subject, arg.Url)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Subject,
		&i.Status,
		&i.Url,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTicketByID = `-- name: GetTicketByID :one
SELECT
	id, user_id, subject, status, url, created_at, updated_at, deleted_at
FROM
	tickets
WHERE
	id = $1
	AND deleted_at IS NULL
`

func (q *Queries) GetTicketByID(ctx context.Context, id uuid.UUID) (*Ticket, error) {
	row := q.db.QueryRowContext(ctx, getTicketByID, id)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Subject,
		&i.Status,
		&i.Url,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTicketByURL = `-- name: GetTicketByURL :one
SELECT
	id, user_id, subject, status, url, created_at, updated_at, deleted_at
FROM
	tickets
WHERE
	url = $1
	AND deleted_at IS NULL
`

func (q *Queries) GetTicketByURL(ctx context.Context, url string) (*Ticket, error) {
	row := q.db.QueryRowContext(ctx, getTicketByURL, url)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Subject,
		&i.Status,
		&i.Url,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getTicketsByUserIDAndPageInfo = `-- name: GetTicketsByUserIDAndPageInfo :many
SELECT
	id, user_id, subject, status, url, created_at, updated_at, deleted_at
FROM
	tickets
WHERE
	(
		user_id = $3
		OR $3 IS NULL
	)
	AND updated_at < $1
	AND deleted_at IS NULL
ORDER BY
	updated_at DESC
LIMIT
	$2
`

type GetTicketsByUserIDAndPageInfoParams struct {
	UpdatedAt time.Time
	Limit     int32
	UserID    uuid.NullUUID
}

func (q *Queries) GetTicketsByUserIDAndPageInfo(ctx context.Context, arg GetTicketsByUserIDAndPageInfoParams) ([]*Ticket, error) {
	rows, err := q.db.QueryContext(ctx, getTicketsByUserIDAndPageInfo, arg.UpdatedAt, arg.Limit, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Ticket{}
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Subject,
			&i.Status,
			&i.Url,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTicketStatus = `-- name: UpdateTicketStatus :one
UPDATE
	tickets
SET
	status = $1
WHERE
	id = $2
	AND deleted_at IS NULL RETURNING id, user_id, subject, status, url, created_at, updated_at, deleted_at
`

type UpdateTicketStatusParams struct {
	Status TicketStatusType
	ID     uuid.UUID
}

func (q *Queries) UpdateTicketStatus(ctx context.Context, arg UpdateTicketStatusParams) (*Ticket, error) {
	row := q.db.QueryRowContext(ctx, updateTicketStatus, arg.Status, arg.ID)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Subject,
		&i.Status,
		&i.Url,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateTicketUpdatedAt = `-- name: UpdateTicketUpdatedAt :one
UPDATE
	tickets
SET
	updated_at = $1
WHERE
	id = $2
	AND deleted_at IS NULL RETURNING id, user_id, subject, status, url, created_at, updated_at, deleted_at
`

type UpdateTicketUpdatedAtParams struct {
	UpdatedAt time.Time
	ID        uuid.UUID
}

func (q *Queries) UpdateTicketUpdatedAt(ctx context.Context, arg UpdateTicketUpdatedAtParams) (*Ticket, error) {
	row := q.db.QueryRowContext(ctx, updateTicketUpdatedAt, arg.UpdatedAt, arg.ID)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Subject,
		&i.Status,
		&i.Url,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
