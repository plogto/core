// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: saved_posts.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const countSavedPostsByUserIDAndPageInfo = `-- name: CountSavedPostsByUserIDAndPageInfo :one
WITH _count_wrapper AS (
	SELECT
		count(*)
	FROM
		saved_posts AS saved_post
		INNER JOIN posts ON posts.id = saved_post.post_id
		INNER JOIN users ON users.id = posts.user_id
		FULL OUTER JOIN connections ON connections.following_id = posts.user_id
	WHERE
		saved_post.user_id = $1
		AND saved_post.deleted_at IS NULL
		AND posts.deleted_at IS NULL
		AND (
			connections.status = 2
			OR users.is_private = FALSE
		)
		AND (
			users.id = $1
			OR connections.deleted_at IS NULL
		)
		AND saved_post.created_at < $2
	GROUP BY
		saved_post.id,
		posts.id,
		users.id
)
SELECT
	count(*)
FROM
	_count_wrapper
`

type CountSavedPostsByUserIDAndPageInfoParams struct {
	UserID    uuid.UUID
	CreatedAt time.Time
}

func (q *Queries) CountSavedPostsByUserIDAndPageInfo(ctx context.Context, arg CountSavedPostsByUserIDAndPageInfoParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSavedPostsByUserIDAndPageInfo, arg.UserID, arg.CreatedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSavedPost = `-- name: CreateSavedPost :one
INSERT INTO
	saved_posts (user_id, post_id)
VALUES
	($1, $2) RETURNING id, user_id, post_id, created_at, updated_at, deleted_at
`

type CreateSavedPostParams struct {
	UserID uuid.UUID
	PostID uuid.UUID
}

func (q *Queries) CreateSavedPost(ctx context.Context, arg CreateSavedPostParams) (*SavedPost, error) {
	row := q.db.QueryRowContext(ctx, createSavedPost, arg.UserID, arg.PostID)
	var i SavedPost
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PostID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteSavedPostByID = `-- name: DeleteSavedPostByID :one
UPDATE
	saved_posts
SET
	deleted_at = $1
WHERE
	id = $2
	AND deleted_at IS NULL RETURNING id, user_id, post_id, created_at, updated_at, deleted_at
`

type DeleteSavedPostByIDParams struct {
	DeletedAt sql.NullTime
	ID        uuid.UUID
}

func (q *Queries) DeleteSavedPostByID(ctx context.Context, arg DeleteSavedPostByIDParams) (*SavedPost, error) {
	row := q.db.QueryRowContext(ctx, deleteSavedPostByID, arg.DeletedAt, arg.ID)
	var i SavedPost
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PostID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getSavedPostByID = `-- name: GetSavedPostByID :one
SELECT
	id, user_id, post_id, created_at, updated_at, deleted_at
FROM
	saved_posts
WHERE
	id = $1
	AND deleted_at IS NULL
`

func (q *Queries) GetSavedPostByID(ctx context.Context, id uuid.UUID) (*SavedPost, error) {
	row := q.db.QueryRowContext(ctx, getSavedPostByID, id)
	var i SavedPost
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PostID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getSavedPostByUserIDAndPostID = `-- name: GetSavedPostByUserIDAndPostID :one
SELECT
	id, user_id, post_id, created_at, updated_at, deleted_at
FROM
	saved_posts
WHERE
	user_id = $1
	AND post_id = $2
	AND deleted_at IS NULL
`

type GetSavedPostByUserIDAndPostIDParams struct {
	UserID uuid.UUID
	PostID uuid.UUID
}

func (q *Queries) GetSavedPostByUserIDAndPostID(ctx context.Context, arg GetSavedPostByUserIDAndPostIDParams) (*SavedPost, error) {
	row := q.db.QueryRowContext(ctx, getSavedPostByUserIDAndPostID, arg.UserID, arg.PostID)
	var i SavedPost
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PostID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getSavedPostsByUserIDAndPageInfo = `-- name: GetSavedPostsByUserIDAndPageInfo :many
WITH _count_wrapper AS (
	SELECT
		saved_post.id AS saved_post_id,
		saved_post.post_id AS saved_post_post_id,
		saved_post.user_id AS saved_post_user_id,
		saved_post.created_at,
		saved_post.deleted_at AS saved_post_deleted_at,
		connections.id AS connection_id,
		connections.status,
		connections.deleted_at AS connection_deleted_at,
		posts.id AS post_id,
		posts.user_id AS post_user_id,
		posts.deleted_at AS post_deleted_at,
		users.id AS user_id,
		users.is_private
	FROM
		saved_posts AS saved_post
		INNER JOIN posts ON posts.id = saved_post.post_id
		INNER JOIN users ON users.id = posts.user_id
		FULL OUTER JOIN connections ON connections.following_id = posts.user_id
	WHERE
		saved_post.user_id = $2
		AND saved_post.deleted_at IS NULL
		AND posts.deleted_at IS NULL
		AND (
			connections.status = 2
			OR users.is_private = FALSE
		)
		AND (
			users.id = $2
			OR connections.deleted_at IS NULL
		)
		AND saved_post.created_at < $3
	GROUP BY
		connections.id,
		saved_post.id,
		posts.id,
		users.id
)
SELECT
	saved_post_id AS id,
	user_id,
	post_id,
	created_at
FROM
	_count_wrapper
GROUP BY
	id,
	user_id,
	post_id,
	created_at
ORDER BY
	created_at DESC
LIMIT
	$1
`

type GetSavedPostsByUserIDAndPageInfoParams struct {
	Limit     int32
	UserID    uuid.UUID
	CreatedAt time.Time
}

type GetSavedPostsByUserIDAndPageInfoRow struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	PostID    uuid.UUID
	CreatedAt time.Time
}

func (q *Queries) GetSavedPostsByUserIDAndPageInfo(ctx context.Context, arg GetSavedPostsByUserIDAndPageInfoParams) ([]*GetSavedPostsByUserIDAndPageInfoRow, error) {
	rows, err := q.db.QueryContext(ctx, getSavedPostsByUserIDAndPageInfo, arg.Limit, arg.UserID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetSavedPostsByUserIDAndPageInfoRow{}
	for rows.Next() {
		var i GetSavedPostsByUserIDAndPageInfoRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PostID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
